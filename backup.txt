library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;

entity Controller is
    Port (
        clk : in STD_LOGIC;
        reset : in STD_LOGIC;
        start : in STD_LOGIC;
        sw_usuario : in STD_LOGIC_VECTOR(6 downto 0);
        ativado : in STD_LOGIC_VECTOR(2 downto 0);
        sw_out : out STD_LOGIC_VECTOR(6 downto 0);
        inicia_Input : out STD_LOGIC;
        vetor_resultado : out std_logic_vector(20 downto 0)
    );
end Controller;

architecture Behavioral of Controller is
    type array_resposta is array (0 to 6) of std_logic_vector(2 downto 0);
    signal resposta_usuario : array_resposta := (others => "000");
    
    type estado_type is (AGUARDA_START, CAPTURANDO, COMPLETO);
    signal estado : estado_type := AGUARDA_START;
    
    signal contador_inputs : integer range 0 to 7 := 0;
    signal vetor_resultado_int : std_logic_vector(20 downto 0) := (others => '0');
    
begin
    vetor_resultado <= vetor_resultado_int;

    -- Processo SENSÍVEL às mudanças no array_resposta
    process(resposta_usuario)
        variable temp_vector : std_logic_vector(20 downto 0);
    begin
        temp_vector := (others => '0');
        for i in 0 to 6 loop
            temp_vector((i*3)+2 downto (i*3)) := resposta_usuario(i);
        end loop;
        vetor_resultado_int <= temp_vector;
    end process;

    process(clk, reset)
    begin
        if reset = '1' then
            estado <= AGUARDA_START;
            contador_inputs <= 0;
            inicia_Input <= '0';
            sw_out <= (others => '0');
            -- Limpa array de resposta
            for i in 0 to 6 loop
                resposta_usuario(i) <= "000";
            end loop;
            
        elsif rising_edge(clk) then
            sw_out <= sw_usuario;
            
            case estado is
                when AGUARDA_START =>
                    inicia_Input <= '0';
                    contador_inputs <= 0;
                    if start = '1' then
                        estado <= CAPTURANDO;
                        inicia_Input <= '1';
                        report "Controller: Iniciando captura";
                    end if;
                    
                when CAPTURANDO =>
                    inicia_Input <= '1';
                    
                    if ativado /= "000" then
                        -- Armazena no array e reporta
                        resposta_usuario(contador_inputs) <= ativado;
                        report "Controller: Input " & integer'image(contador_inputs) & 
                               " = " & integer'image(to_integer(unsigned(ativado))) &
                               " (bin: " & 
                               std_logic'image(ativado(2)) & 
                               std_logic'image(ativado(1)) & 
                               std_logic'image(ativado(0)) & ")";
                        
                        contador_inputs <= contador_inputs + 1;
                        
                        if contador_inputs = 6 then
                            estado <= COMPLETO;
                            inicia_Input <= '0';
                            report "Controller: Captura completa!";
                            -- Mostra o vetor final
                            report "Vetor final: " & 
                                   integer'image(to_integer(unsigned(vetor_resultado_int)));
                            for i in 0 to 6 loop
                                report "Pos " & integer'image(i) & ": " & 
                                       integer'image(to_integer(unsigned(resposta_usuario(i))));
                            end loop;
                        end if;
                    end if;
                    
                when COMPLETO =>
                    inicia_Input <= '0';
                    if reset = '1' then
                        estado <= AGUARDA_START;
                    end if;
                    
            end case;
        end if;
    end process;

end Behavioral;